import { Client } from 'pg';
import { BadRequestError, DuplicateKeyError } from "../../../errors/index.js";
import { IEntity } from '@loomcore/common/models';
import type { AppIdType } from '@loomcore/common/types';

export async function createMany<T extends IEntity>(
    client: Client,
    pluralResourceName: string,
    entities: Partial<T>[]
): Promise<{ insertedIds: AppIdType[]; entities: T[] }> {
    if (entities.length === 0) {
        return {
            insertedIds: [],
            entities: []
        };
    }

    // Note: if the provided entities have different column sets, each column not provided by an entity will be set to null.
    //  This is most likely not the desired behavior. Entities passed in to createMany should provide the same columns.
    try {
        // Remove _id from all entities - it will be auto-generated by the database
        entities.forEach(entity => {
            delete entity._id;
        });
        
        // Find the union of all columns across all entities
        const allColumns = new Set<string>();
        entities.forEach(entity => {
            Object.keys(entity).forEach(key => {
                if (key !== '_id') {
                    allColumns.add(key);
                }
            });
        });

        const columns = Array.from(allColumns);
        if (columns.length === 0) {
            throw new BadRequestError(`No columns provided for ${pluralResourceName}`);
        }

        // Build parameterized query with multiple VALUES clauses
        const allValues: any[] = [];
        const valueClauses: string[] = [];
        
        entities.forEach((entity, entityIndex) => {
            const values = columns.map(column => entity[column as keyof typeof entity]);
            const placeholders = values.map((_, valueIndex) => {
                const paramIndex = entityIndex * columns.length + valueIndex + 1;
                return `$${paramIndex}`;
            }).join(', ');
            
            valueClauses.push(`(${placeholders})`);
            allValues.push(...values);
        });

        const query = `
            INSERT INTO "${pluralResourceName}" (${columns.map(col => `"${col}"`).join(', ')})
            VALUES ${valueClauses.join(', ')}
            RETURNING *
        `;

        const result = await client.query<T>(query, allValues);
        
        if (result.rows.length !== entities.length) {
            throw new BadRequestError(`Error creating ${pluralResourceName}: Expected ${entities.length} rows, got ${result.rows.length}`);
        }
        
        // Get the actual database rows with all converted values
        const insertedRows = result.rows;
        const insertedIds = insertedRows.map(row => row._id as AppIdType);
        
        return {
            insertedIds,
            entities: insertedRows
        };
    }
    catch (err: any) {
        // PostgreSQL error code 23505 is for unique constraint violations
        if (err.code === '23505') {
            throw new DuplicateKeyError(`One or more ${pluralResourceName} already exist`);
        }
        throw new BadRequestError(`Error creating ${pluralResourceName}: ${err.message}`);
    }
}

